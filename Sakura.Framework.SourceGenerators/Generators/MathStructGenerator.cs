// This code is part of the Sakura framework project. Licensed under the MIT License.
// See the LICENSE file for full license text.

#nullable disable

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Sakura.Framework.SourceGenerators.Generators;

/// <summary>
/// The source generator that generates wrapper methods for struct name "MathStruct" to
/// generate operator overloads and static methods that forward calls to the underlying System.Numerics type.
/// This allows for seamless integration and usage of these math structs in the Sakura framework.
/// </summary>
[Generator]
public class MathStructGenerator : IIncrementalGenerator
{
    /// <summary>
    /// The full name of the MathStruct attribute in the framework.
    /// </summary>
    private const string math_struct_attribute_name = "Sakura.Framework.Maths.MathStructAttribute";

    /// <summary>
    /// Enable source debugging by emitting generated files to a specified directory.
    /// This can be controlled via the MSBuild property "SakuraGenerator_EnableSourceDebugging"
    /// and "SakuraGenerator_EmitSourcePath" should be set to a valid directory path.
    /// </summary>
    private bool enableSourceDebugging = false;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all struct declarations with the MathStruct attribute.
        var structProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                math_struct_attribute_name,
                predicate: (node, _) => node is StructDeclarationSyntax,
                transform: (ctx, _) => getStructInfo(ctx)
            )
            .Where(static s => s is not null);

        var compilationAndStructs = context.CompilationProvider
            .Combine(structProvider.Collect())
            .Combine(context.AnalyzerConfigOptionsProvider);

        context.RegisterSourceOutput(compilationAndStructs, (spc, source) =>
        {
            var ((compilation, structs), options) = source;
            if (structs.IsDefaultOrEmpty) return;

            options.GlobalOptions.TryGetValue("build_property.SakuraGenerator_EmitSourcePath", out string emitPath);
            options.GlobalOptions.TryGetValue("build_property.SakuraGenerator_EnableSourceDebugging", out string enableDebugging);
            enableSourceDebugging = bool.TryParse(enableDebugging, out bool result) && result;

            // Create a map from Sakura wrapper type to underlying System.Numerics type
            // This will help when sometimes the Sakura type still not exists but the underlying type does.
            // e.g. If Sakura's Vector4 is not defined so the method will accept System.Numerics.Vector4 instead.
            // but if Sakura's Vector4 is defined, we will use that instead.
            // This allows for more flexible usage of the generated methods.
            var typeMap = structs.ToDictionary(s => s.UnderlyingTypeFullName, s => s.WrapperName);

            foreach (var structInfo in structs)
            {
                generateWrapperCode(spc, structInfo, typeMap, emitPath);
            }
        });
    }

    private static StructInfo getStructInfo(GeneratorAttributeSyntaxContext context)
    {
        var structSymbol = (INamedTypeSymbol)context.TargetSymbol;

        var valueField = structSymbol.GetMembers("Value").OfType<IFieldSymbol>().FirstOrDefault();
        if (valueField is null) return null;

        return new StructInfo(
            structSymbol.Name,
            structSymbol.ContainingNamespace.ToDisplayString(),
            valueField.Type
        );
    }

    private void generateWrapperCode(SourceProductionContext context, StructInfo structInfo,
        IReadOnlyDictionary<string, string> typeMap, string emitPath)
    {
        (string wrapperName, string namespaceName, var underlyingType) = structInfo;
        string underlyingTypeName = underlyingType.ToDisplayString();

        var code = new StringBuilder();

        code.AppendLine($"// <auto-generated>");
        code.AppendLine($"// This code is generated by the Sakura.Framework source generator. ({GetType().FullName}");
        code.AppendLine($"// Type wrapper for {underlyingTypeName} for {wrapperName}. (enableSourceDebugging: {enableSourceDebugging})");
        code.AppendLine($"// </auto-generated>");
        code.AppendLine($"namespace {namespaceName};");
        code.AppendLine();
        code.AppendLine($"/// <summary>");
        code.AppendLine($"/// Additional methods and operator overloads for <see cref=\"{wrapperName}\"/> that forward calls to <see cref=\"{underlyingTypeName}\"/>.");
        code.AppendLine($"/// </summary>");
        code.AppendLine($"public readonly partial struct {wrapperName}");
        code.AppendLine("{");

        var members = underlyingType.GetMembers();

        // Operator overloads
        foreach (var member in members.OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.UserDefinedOperator && m.IsStatic))
        {
            // We only generate operators where all parameters can be mapped to our wrappers or are primitives.
            if (!member.Parameters.All(p => typeMap.ContainsKey(p.Type.ToDisplayString()) || p.Type.SpecialType != SpecialType.None))
                continue;

            string operatorSymbol = getOperatorSymbol(member.Name);

            // Skip operators we don't have a symbol for.
            if (operatorSymbol is null)
                continue;

            string returnTypeName = getMappedTypeName(member.ReturnType, typeMap);
            string parameters = string.Join(", ", member.Parameters.Select(p => $"{getMappedTypeName(p.Type, typeMap)} {p.Name}"));

            // Correctly construct the implementation body (e.g., "left + right" or "-value")
            string implementation;
            if (member.Parameters.Length == 1)
            {
                implementation = $"{operatorSymbol}{member.Parameters[0].Name}";
            }
            else if (member.Parameters.Length == 2)
            {
                implementation = $"{member.Parameters[0].Name} {operatorSymbol} {member.Parameters[1].Name}";
            }
            else
            {
                // Not a unary or binary operator we can handle, so skip.
                continue;
            }

            string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
            if (!string.IsNullOrEmpty(docXml))
                code.AppendLine(formatDocumentation(docXml));

            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public static {returnTypeName} operator {operatorSymbol}({parameters}) => {implementation};");
            code.AppendLine();
        }

        // Static methods
        foreach (var member in members.OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary && m.IsStatic && m.DeclaredAccessibility == Accessibility.Public))
        {
            // Skip methods that return types we don't know how to handle (e.g., generic types)
            if (member.IsGenericMethod) continue;

            string returnTypeName = getMappedTypeName(member.ReturnType, typeMap);
            string parameters = string.Join(", ", member.Parameters.Select(p => $"{getMappedTypeName(p.Type, typeMap)} {p.Name}"));
            string arguments = string.Join(", ", member.Parameters.Select(p => p.Name));

            string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
            if (!string.IsNullOrEmpty(docXml))
                code.AppendLine(formatDocumentation(docXml));
            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public static {returnTypeName} {member.Name}({parameters}) => {underlyingTypeName}.{member.Name}({arguments});");
            code.AppendLine();
        }

        // Instance methods and properties
        foreach (var member in members)
        {
            // We'll handle common instance methods and properties like Length() and LengthSquared()
            if (member.IsStatic || member.DeclaredAccessibility != Accessibility.Public) continue;

            if (member is IMethodSymbol { MethodKind: MethodKind.Ordinary, IsGenericMethod: false } method && method.Parameters.IsEmpty)
            {
                string returnTypeName = getMappedTypeName(method.ReturnType, typeMap);
                string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
                if (!string.IsNullOrEmpty(docXml))
                    code.AppendLine(formatDocumentation(docXml));
                code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
                code.AppendLine($"    public {returnTypeName} {method.Name}() => this.Value.{method.Name}();");
                code.AppendLine();
            }
            else if (member is IPropertySymbol property && property.GetMethod != null)
            {
                // This could generate wrappers for properties like Vector3.One, etc. if they were instance. (They are static, handled above)
                // We can also add instance properties if they exist on the underlying type.
            }
        }

        code.AppendLine("}");

        string finalCode = code.ToString();

        // Write to files if emitPath is specified (for debugging purposes)
        if (!string.IsNullOrEmpty(emitPath) && enableSourceDebugging)
        {
            try
            {
#pragma warning disable RS1035 // Do not do file IO in analyzers
                Directory.CreateDirectory(emitPath);
                Directory.CreateDirectory(Path.Combine(emitPath, namespaceName));
                // There is a problem when write into the .cs file directly, the comment will be removed out.
                // Not sure why, but for now we write into a .g.txt file instead
                // and then rename it to .cs manually.
                string filePath = Path.Combine(emitPath, namespaceName, $"{wrapperName}.g.txt");
                File.WriteAllText(filePath, finalCode);
                string csFilePath = Path.ChangeExtension(filePath, ".cs");
                if (File.Exists(csFilePath))
                    File.Delete(csFilePath);
                File.Move(filePath, csFilePath);
#pragma warning restore RS1035
            }
            catch (IOException ex)
            {
                // Add a diagnostic if file writing fails
                context.ReportDiagnostic(Diagnostic.Create("SG001", "FileEmit", $"Failed to write generated file: {ex.Message}", DiagnosticSeverity.Warning, DiagnosticSeverity.Warning, true, 1));
            }
        }

        context.AddSource($"{wrapperName}.g.cs", finalCode);
    }

    private string getMappedTypeName(ITypeSymbol typeSymbol, IReadOnlyDictionary<string, string> typeMap)
    {
        string fullName = typeSymbol.ToDisplayString();
        return typeMap.TryGetValue(fullName, out string wrapperName) ? wrapperName : fullName;
    }

    /// <summary>
    /// Convert Roslyn operator method names to their corresponding symbols.
    /// </summary>
    /// <param name="metadataName">Roslyn metadata name of the operator method.</param>
    /// <returns></returns>
    private string getOperatorSymbol(string metadataName)
    {
        switch (metadataName)
        {
            case "op_Addition": return "+";
            case "op_Subtraction": return "-";
            case "op_Multiply": return "*";
            case "op_Division": return "/";
            case "op_UnaryNegation": return "-";
            case "op_Equality": return "==";
            case "op_Inequality": return "!=";
            default: return null; // Unknown operator
        }
    }

    /// <summary>
    /// Formats the raw documentation XML into lines prefixed with "/// ".
    /// </summary>
    private string formatDocumentation(string xml)
    {
        if (string.IsNullOrEmpty(xml)) return string.Empty;

        var doc = new XmlDocument();
        doc.LoadXml(xml);

        var builder = new StringBuilder();
        var childNodes = doc.DocumentElement?.ChildNodes;

        if (childNodes is null) return string.Empty;

        // Iterate through each node (<summary>, <param>, etc.) individually
        foreach (XmlNode node in childNodes)
        {
            // Get the complete tag as a string (e.g., "<summary>...</summary>")
            string nodeXml = node.OuterXml;
            if (string.IsNullOrWhiteSpace(nodeXml)) continue;

            // Split the tag's content by newlines, in case the original summary is multi-line
            string[] lines = nodeXml.Replace("\r\n", "\n").Split('\n');
            foreach (string line in lines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                // Add an extra space for better formatting in the final code
                builder.AppendLine($"    /// {line.Trim()}");
            }
        }
        return builder.ToString().TrimEnd();
    }

    private record StructInfo(string WrapperName, string NamespaceName, ITypeSymbol UnderlyingType)
    {
        public string UnderlyingTypeFullName => UnderlyingType.ToDisplayString();
        public string WrapperName { get; } = WrapperName;
        public string NamespaceName { get; } = NamespaceName;
        public ITypeSymbol UnderlyingType { get; } = UnderlyingType;
    }
}
