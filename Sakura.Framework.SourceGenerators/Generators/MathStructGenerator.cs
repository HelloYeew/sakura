// This code is part of the Sakura framework project. Licensed under the MIT License.
// See the LICENSE file for full license text.

#nullable disable

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Sakura.Framework.SourceGenerators.Generators;

/// <summary>
/// The source generator that generates wrapper methods for struct name "MathStruct" to
/// generate operator overloads and static methods that forward calls to the underlying System.Numerics type.
/// This allows for seamless integration and usage of these math structs in the Sakura framework.
/// </summary>
[Generator]
public class MathStructGenerator : IIncrementalGenerator
{
    /// <summary>
    /// The full name of the MathStruct attribute in the framework.
    /// </summary>
    private const string math_struct_attribute_name = "Sakura.Framework.Maths.MathStructAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all struct declarations with the MathStruct attribute.
        var structProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                math_struct_attribute_name,
                predicate: (node, _) => node is StructDeclarationSyntax,
                transform: (ctx, _) => getStructInfo(ctx)
            )
            .Where(static s => s is not null);

        // Collect all found structs into a list
        var collectedStructs = structProvider.Collect();

        context.RegisterSourceOutput(collectedStructs, (spc, source) =>
        {
            if (source.IsDefaultOrEmpty) return;

            // Create a map from Sakura wrapper type to underlying System.Numerics type
            // This will help when sometimes the Sakura type still not exists but the underlying type does.
            // e.g. If Sakura's Vector4 is not defined so the method will accept System.Numerics.Vector4 instead.
            // but if Sakura's Vector4 is defined, we will use that instead.
            // This allows for more flexible usage of the generated methods.
            var typeMap = source.ToDictionary(s => s.UnderlyingTypeFullName, s => s.WrapperName);

            foreach (var structInfo in source)
            {
                generateWrapperCode(spc, structInfo, typeMap);
            }
        });
    }

    private static StructInfo getStructInfo(GeneratorAttributeSyntaxContext context)
    {
        var structSymbol = (INamedTypeSymbol)context.TargetSymbol;

        var valueField = structSymbol.GetMembers("Value").OfType<IFieldSymbol>().FirstOrDefault();
        if (valueField is null) return null;

        return new StructInfo(
            structSymbol.Name,
            structSymbol.ContainingNamespace.ToDisplayString(),
            valueField.Type
        );
    }

    private void generateWrapperCode(SourceProductionContext context, StructInfo structInfo,
        IReadOnlyDictionary<string, string> typeMap)
    {
        (string wrapperName, string namespaceName, var underlyingType) = structInfo;
        string underlyingTypeName = underlyingType.ToDisplayString();

        var code = new StringBuilder();

        code.AppendLine($"// <auto-generated>");
        code.AppendLine($"// This code is generated by the Sakura.Framework source generator.");
        code.AppendLine($"// Type wrapper for {underlyingTypeName} for {wrapperName}.");
        code.AppendLine($"// </auto-generated>");
        code.AppendLine($"namespace {namespaceName};");
        code.AppendLine();
        code.AppendLine($"public readonly partial struct {wrapperName}");
        code.AppendLine("{");

        var members = underlyingType.GetMembers();

        // Operator overloads
        foreach (var member in members.OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.BuiltinOperator && m.IsStatic))
        {
            // We only generate operators where all parameters can be mapped to our wrappers or are primitives.
            if (!member.Parameters.All(p => typeMap.ContainsKey(p.Type.ToDisplayString()) || p.Type.SpecialType != SpecialType.None))
                continue;

            string operatorSymbol = getOperatorSymbol(member.Name);

            string returnTypeName = getMappedTypeName(member.ReturnType, typeMap);
            string parameters = string.Join(", ", member.Parameters.Select(p => $"{getMappedTypeName(p.Type, typeMap)} {p.Name}"));
            string arguments = string.Join(", ", member.Parameters.Select(p => p.Name));

            string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
            if (!string.IsNullOrEmpty(docXml))
                code.AppendLine(formatDocumentation(docXml));
            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public static {returnTypeName} operator {operatorSymbol}({parameters}) => {arguments};");
            code.AppendLine();
        }

        // Static methods
        foreach (var member in members.OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary && m.IsStatic && m.DeclaredAccessibility == Accessibility.Public))
        {
            // Skip methods that return types we don't know how to handle (e.g., generic types)
            if (member.IsGenericMethod) continue;

            string returnTypeName = getMappedTypeName(member.ReturnType, typeMap);
            string parameters = string.Join(", ", member.Parameters.Select(p => $"{getMappedTypeName(p.Type, typeMap)} {p.Name}"));
            string arguments = string.Join(", ", member.Parameters.Select(p => p.Name));

            string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
            if (!string.IsNullOrEmpty(docXml))
                code.AppendLine(formatDocumentation(docXml));
            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public static {returnTypeName} {member.Name}({parameters}) => {underlyingTypeName}.{member.Name}({arguments});");
            code.AppendLine();
        }

        // Instance methods and properties
        foreach (var member in members)
        {
            // We'll handle common instance methods and properties like Length() and LengthSquared()
            if (member.IsStatic || member.DeclaredAccessibility != Accessibility.Public) continue;

            if (member is IMethodSymbol { MethodKind: MethodKind.Ordinary, IsGenericMethod: false } method && method.Parameters.IsEmpty)
            {
                string returnTypeName = getMappedTypeName(method.ReturnType, typeMap);
                string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
                if (!string.IsNullOrEmpty(docXml))
                    code.AppendLine(formatDocumentation(docXml));
                code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
                code.AppendLine($"    public {returnTypeName} {method.Name}() => this.Value.{method.Name}();");
                code.AppendLine();
            }
            else if (member is IPropertySymbol property && property.GetMethod != null)
            {
                // This could generate wrappers for properties like Vector3.One, etc. if they were instance. (They are static, handled above)
                // We can also add instance properties if they exist on the underlying type.
            }
        }

        code.AppendLine("}");

        context.AddSource($"{wrapperName}.g.cs", code.ToString());
    }

    private string getMappedTypeName(ITypeSymbol typeSymbol, IReadOnlyDictionary<string, string> typeMap)
    {
        string fullName = typeSymbol.ToDisplayString();
        return typeMap.TryGetValue(fullName, out string wrapperName) ? wrapperName : fullName;
    }

    /// <summary>
    /// Convert Roslyn operator method names to their corresponding symbols.
    /// </summary>
    /// <param name="metadataName">Roslyn metadata name of the operator method.</param>
    /// <returns></returns>
    private string getOperatorSymbol(string metadataName)
    {
        switch (metadataName)
        {
            case "op_Addition": return "+";
            case "op_Subtraction": return "-";
            case "op_Multiply": return "*";
            case "op_Division": return "/";
            case "op_UnaryNegation": return "-";
            case "op_Equality": return "==";
            case "op_Inequality": return "!=";
            default: return null; // Unknown operator
        }
    }

    /// <summary>
    /// Formats the raw documentation XML into lines prefixed with "/// ".
    /// </summary>
    private string formatDocumentation(string xml)
    {
        if (string.IsNullOrEmpty(xml)) return string.Empty;

        var doc = new XmlDocument();
        doc.LoadXml(xml);

        var builder = new StringBuilder();
        var childNodes = doc.DocumentElement?.ChildNodes;

        if (childNodes is null) return string.Empty;

        // Iterate through each node (<summary>, <param>, etc.) individually
        foreach (XmlNode node in childNodes)
        {
            // Get the complete tag as a string (e.g., "<summary>...</summary>")
            string nodeXml = node.OuterXml;
            if (string.IsNullOrWhiteSpace(nodeXml)) continue;

            // Split the tag's content by newlines, in case the original summary is multi-line
            string[] lines = nodeXml.Replace("\r\n", "\n").Split('\n');
            foreach (string line in lines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                // Add an extra space for better formatting in the final code
                builder.AppendLine($"    /// {line.Trim()}");
            }
        }
        return builder.ToString().TrimEnd();
    }

    private record StructInfo(string WrapperName, string NamespaceName, ITypeSymbol UnderlyingType)
    {
        public string UnderlyingTypeFullName => UnderlyingType.ToDisplayString();
        public string WrapperName { get; } = WrapperName;
        public string NamespaceName { get; } = NamespaceName;
        public ITypeSymbol UnderlyingType { get; } = UnderlyingType;
    }
}
