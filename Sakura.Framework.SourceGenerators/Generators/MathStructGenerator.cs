// This code is part of the Sakura framework project. Licensed under the MIT License.
// See the LICENSE file for full license text.

#nullable disable

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Sakura.Framework.SourceGenerators.Generators;

/// <summary>
/// The source generator that generates wrapper methods for struct name "MathStruct" to
/// generate operator overloads and static methods that forward calls to the underlying System.Numerics type.
/// This allows for seamless integration and usage of these math structs in the Sakura framework.
/// (System.Numerics source: https://github.com/dotnet/runtime/tree/main/src/libraries/System.Private.CoreLib/src/System/Numerics
/// </summary>
[Generator]
public class MathStructGenerator : IIncrementalGenerator
{
    /// <summary>
    /// The full name of the MathStruct attribute in the framework.
    /// </summary>
    private const string math_struct_attribute_name = "Sakura.Framework.Maths.MathStructAttribute";

    /// <summary>
    /// Enable source debugging by emitting generated files to a specified directory.
    /// This can be controlled via the MSBuild property "SakuraGenerator_EnableSourceDebugging"
    /// and "SakuraGenerator_EmitSourcePath" should be set to a valid directory path.
    /// </summary>
    private bool enableSourceDebugging = false;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all struct declarations with the MathStruct attribute.
        var structProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                math_struct_attribute_name,
                predicate: (node, _) => node is StructDeclarationSyntax,
                transform: (ctx, _) => getStructInfo(ctx)
            )
            .Where(static s => s is not null);

        var compilationAndStructs = context.CompilationProvider
            .Combine(structProvider.Collect())
            .Combine(context.AnalyzerConfigOptionsProvider);

        context.RegisterSourceOutput(compilationAndStructs, (spc, source) =>
        {
            var ((compilation, structs), options) = source;
            if (structs.IsDefaultOrEmpty) return;

            options.GlobalOptions.TryGetValue("build_property.SakuraGenerator_EmitSourcePath", out string emitPath);
            options.GlobalOptions.TryGetValue("build_property.SakuraGenerator_EnableSourceDebugging", out string enableDebugging);
            enableSourceDebugging = bool.TryParse(enableDebugging, out bool result) && result;

            // Create a map from Sakura wrapper type to underlying System.Numerics type
            // This will help when sometimes the Sakura type still not exists but the underlying type does.
            // e.g. If Sakura's Vector4 is not defined so the method will accept System.Numerics.Vector4 instead.
            // but if Sakura's Vector4 is defined, we will use that instead.
            // This allows for more flexible usage of the generated methods.
            var typeMap = structs.ToDictionary(s => s.UnderlyingTypeFullName, s => s.WrapperName);

            foreach (var structInfo in structs)
            {
                generateWrapperCode(spc, structInfo, typeMap, emitPath);
            }
        });
    }

    private static StructInfo getStructInfo(GeneratorAttributeSyntaxContext context)
    {
        var structSymbol = (INamedTypeSymbol)context.TargetSymbol;

        var valueField = structSymbol.GetMembers("Value").OfType<IFieldSymbol>().FirstOrDefault();
        if (valueField is null) return null;

        return new StructInfo(
            structSymbol.Name,
            structSymbol.ContainingNamespace.ToDisplayString(),
            valueField.Type
        );
    }

    private void generateWrapperCode(SourceProductionContext context, StructInfo structInfo,
        IReadOnlyDictionary<string, string> typeMap, string emitPath)
    {
        (string wrapperName, string namespaceName, var underlyingType) = structInfo;
        string underlyingTypeName = underlyingType.ToDisplayString();

        bool generatedEqualityOperator = false;

        // Check if the underlying type implements IEquatable<T> for itself.
        // e.g., System.Numerics.Vector2 implements IEquatable<System.Numerics.Vector2>
        var iEquatableInterface = underlyingType.AllInterfaces.FirstOrDefault(i =>
            i.IsGenericType &&
            i.OriginalDefinition.ToDisplayString() == "System.IEquatable<T>" &&
            SymbolEqualityComparer.Default.Equals(i.TypeArguments[0], underlyingType));

        var code = new StringBuilder();

        code.AppendLine($"// <auto-generated>");
        code.AppendLine($"// This code is generated by the Sakura framework source generator.");
        code.AppendLine($"// Generator name : {GetType().FullName}");
        code.AppendLine($"// Type wrapper for {underlyingTypeName} for {wrapperName}");
        code.AppendLine($"// Last updated : {System.DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        code.AppendLine($"// </auto-generated>");
        code.AppendLine($"namespace {namespaceName};");
        code.AppendLine();

        // Add IEquatable<T> to the struct definition if the underlying type supports it.
        string interfaceDeclaration = iEquatableInterface != null ? $" : System.IEquatable<{wrapperName}>" : "";
        code.AppendLine($"public partial struct {wrapperName}{interfaceDeclaration}");
        code.AppendLine("{");

        var members = underlyingType.GetMembers();

        // Constructors
        foreach (var member in members.OfType<IMethodSymbol>().Where(m =>
                     m.MethodKind == MethodKind.Constructor &&
                     m.DeclaredAccessibility == Accessibility.Public &&
                     !m.Parameters.IsEmpty))
        {
            string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
            if (!string.IsNullOrEmpty(docXml))
                code.AppendLine(formatDocumentation(docXml));

            // Build the parameter list (e.g., "float x, float y")
            string parameters = string.Join(", ", member.Parameters.Select(p => $"{getMappedTypeName(p.Type, typeMap)} {p.Name}"));

            // Build the argument list for the 'new' call (e.g., "x, y")
            string arguments = string.Join(", ", member.Parameters.Select(p => p.Name));

            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public {wrapperName}({parameters})");
            code.AppendLine($"    {{");
            code.AppendLine($"        this.Value = new {underlyingTypeName}({arguments});");
            code.AppendLine($"    }}");
            code.AppendLine();
        }

        // Operator overloads
        foreach (var member in members.OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.UserDefinedOperator && m.IsStatic))
        {
            if (member.Name is "op_Equality" or "op_Inequality")
            {
                generatedEqualityOperator = true;
            }

            // We only generate operators where all parameters can be mapped to our wrappers or are primitives.
            if (!member.Parameters.All(p => typeMap.ContainsKey(p.Type.ToDisplayString()) || p.Type.SpecialType != SpecialType.None))
                continue;

            string operatorSymbol = getOperatorSymbol(member.Name);

            // Skip operators we don't have a symbol for.
            if (operatorSymbol is null)
                continue;

            string returnTypeName = getMappedTypeName(member.ReturnType, typeMap);
            string parameters = string.Join(", ", member.Parameters.Select(p => $"{getMappedTypeName(p.Type, typeMap)} {p.Name}"));

            // Correctly construct the implementation body (e.g., "left + right" or "-value")
            string implementation;
            if (member.Parameters.Length == 1)
            {
                implementation = $"{operatorSymbol}{member.Parameters[0].Name}";
            }
            else if (member.Parameters.Length == 2)
            {
                implementation = $"{member.Parameters[0].Name} {operatorSymbol} {member.Parameters[1].Name}";
            }
            else
            {
                // Not a unary or binary operator we can handle, so skip.
                continue;
            }

            string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
            if (!string.IsNullOrEmpty(docXml))
                code.AppendLine(formatDocumentation(docXml));

            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public static {returnTypeName} operator {operatorSymbol}({parameters}) => {implementation};");
            code.AppendLine();
        }

        // Static methods
        foreach (var member in members.OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary && m.IsStatic && m.DeclaredAccessibility == Accessibility.Public))
        {
            // Skip methods that return types we don't know how to handle (e.g., generic types)
            if (member.IsGenericMethod) continue;

            string returnTypeName = getMappedTypeName(member.ReturnType, typeMap);
            string parameters = string.Join(", ", member.Parameters.Select(p => $"{getParameterModifier(p)}{getMappedTypeName(p.Type, typeMap)} {p.Name}"));

            string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
            if (!string.IsNullOrEmpty(docXml))
                code.AppendLine(formatDocumentation(docXml));
            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");

            // Check if any parameter is 'out' or 'ref'.
            // Since 'out' keyword is not support the implicit conversion so we need to handle it manually.
            bool hasRefOutParams = member.Parameters.Any(p => p.RefKind is RefKind.Out or RefKind.Ref);

            if (hasRefOutParams)
            {
                // Generate a full method body to handle the conversion manually.
                code.AppendLine($"    public static {returnTypeName} {member.Name}({parameters})");
                code.AppendLine($"    {{");

                // Create temporary local variables for each 'out' or 'ref' parameter.
                var arguments = new List<string>();
                foreach (var p in member.Parameters)
                {
                    if (p.RefKind is RefKind.Out or RefKind.Ref)
                    {
                        string tempVarName = $"{p.Name}Underlying";
                        // For 'ref', initialize the temp var with the input value. For 'out', it's uninitialized.
                        string initialization = p.RefKind == RefKind.Ref ? $" = {p.Name}.Value;" : ";";
                        code.AppendLine($"        {p.Type.ToDisplayString()} {tempVarName}{initialization}");
                        arguments.Add($"{getParameterModifier(p)}{tempVarName}");
                    }
                    else
                    {
                        arguments.Add(p.Name);
                    }
                }

                string argumentsString = string.Join(", ", arguments);
                string returnStatement;
                string methodCall;

                if (member.ReturnsVoid)
                {
                    methodCall = $"        {underlyingTypeName}.{member.Name}({argumentsString});";
                    returnStatement = "";
                }
                else
                {
                    // Capture the result in a uniquely named variable.
                    methodCall = $"        var returnValue = {underlyingTypeName}.{member.Name}({argumentsString});";
                    returnStatement = "        return returnValue;";
                }

                // Call the underlying method.
                code.AppendLine(methodCall);
                // Assign the results from the temporary variables back to the original 'out'/'ref' parameters.
                foreach (var p in member.Parameters)
                {
                    if (p.RefKind is RefKind.Out or RefKind.Ref)
                    {
                        code.AppendLine($"        {p.Name} = {p.Name}Underlying;");
                    }
                }

                if (!member.ReturnsVoid)
                {
                    code.AppendLine(returnStatement);
                }

                code.AppendLine($"    }}");
            }
            else
            {
                // Original logic for simple expression-bodied methods.
                string arguments = string.Join(", ", member.Parameters.Select(p => $"{getParameterModifier(p)}{p.Name}"));
                code.AppendLine($"    public static {returnTypeName} {member.Name}({parameters}) => {underlyingTypeName}.{member.Name}({arguments});");
            }
            code.AppendLine();
        }

        // Instance methods and properties
        foreach (var member in members)
        {
            // We'll handle common instance methods and properties like Length() and LengthSquared()
            if (member.IsStatic || member.DeclaredAccessibility != Accessibility.Public) continue;

            if (member is IMethodSymbol { MethodKind: MethodKind.Ordinary, IsGenericMethod: false } method && method.Parameters.IsEmpty)
            {
                // If we generated equality operators, we will handle these methods manually
                // in a dedicated block later to ensure the warnings are resolved.
                if (generatedEqualityOperator && method.IsOverride && (method.Name is "Equals" or "GetHashCode"))
                {
                    continue;
                }

                // Check if all parameters can be mapped from our wrapper types or are primitives
                if (!method.Parameters.All(p => typeMap.ContainsKey(p.Type.ToDisplayString()) || p.Type.SpecialType != SpecialType.None))
                    continue;

                string overrideKeyword = method.IsOverride ? "override " : "";
                string returnTypeName = getMappedTypeName(method.ReturnType, typeMap);
                string parameters = string.Join(", ", method.Parameters.Select(p => $"{getMappedTypeName(p.Type, typeMap)} {p.Name}"));
                string arguments = string.Join(", ", method.Parameters.Select(p => p.Name));

                string docXml = member.GetDocumentationCommentXml(cancellationToken: context.CancellationToken);
                if (!string.IsNullOrEmpty(docXml))
                    code.AppendLine(formatDocumentation(docXml));

                code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");

                // Special handling for Equals(object obj) to prevent comparing a wrapper with a raw underlying type.
                if (method.IsOverride && method.Name == "Equals" && method.Parameters.Length == 1 && method.Parameters[0].Type.SpecialType == SpecialType.System_Object)
                {
                    code.AppendLine($"    public override bool Equals(object obj) => obj is {wrapperName} other && this.Value.Equals(other.Value);");
                }
                else
                {
                    code.AppendLine($"    public {overrideKeyword}{returnTypeName} {method.Name}({parameters}) => this.Value.{method.Name}({arguments});");
                }
                code.AppendLine();
            }
            else if (member is IPropertySymbol property && property.GetMethod != null)
            {
                // This could generate wrappers for properties like Vector3.One, etc. if they were instance. (They are static, handled above)
                // We can also add instance properties if they exist on the underlying type.
            }
        }

        // If we generated == or != operators, we MUST provide Equals and GetHashCode
        // to satisfy compiler warnings CS0660 and CS0661.
        if (generatedEqualityOperator)
        {
            // Implementation for IEquatable<T>.Equals(T other)
            string equatableDoc = """
                /// <summary>Indicates whether the current object is equal to another object of the same type.</summary>
                /// <param name="other">An object to compare with this object.</param>
                /// <returns><c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <c>false</c>.</returns>
            """;
            code.AppendLine(equatableDoc);
            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public bool Equals({wrapperName} other) => this.Value.Equals(other.Value);");
            code.AppendLine();

            // Override for Object.Equals(object o)
            string objectEqualsDoc = """
                /// <summary>Indicates whether this instance and a specified object are equal.</summary>
                /// <param name="obj">The object to compare with the current instance.</param>
                /// <returns><c>true</c> if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, <c>false</c>.</returns>
            """;
            code.AppendLine(objectEqualsDoc);
            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public override bool Equals(object obj) => obj is {wrapperName} other && Equals(other);");
            code.AppendLine();

            // Override for Object.GetHashCode()
            string hashCodeDoc = """
                /// <summary>Returns the hash code for this instance.</summary>
                /// <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
            """;
            code.AppendLine(hashCodeDoc);
            code.AppendLine($"    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            code.AppendLine($"    public override int GetHashCode() => this.Value.GetHashCode();");
        }

        code.AppendLine("}");

        string finalCode = code.ToString();

        // Write to files if emitPath is specified (for debugging purposes)
        if (!string.IsNullOrEmpty(emitPath) && enableSourceDebugging)
        {
            try
            {
#pragma warning disable RS1035 // Do not do file IO in analyzers
                Directory.CreateDirectory(emitPath);
                Directory.CreateDirectory(Path.Combine(emitPath, namespaceName));
                // There is a problem when write into the .cs file directly, the comment will be removed out.
                // Not sure why, but for now we write into a .g.txt file instead
                // and then rename it to .cs manually.
                string filePath = Path.Combine(emitPath, namespaceName, $"{wrapperName}.g.txt");
                File.WriteAllText(filePath, finalCode);
                string csFilePath = Path.ChangeExtension(filePath, ".cs");
                if (File.Exists(csFilePath))
                    File.Delete(csFilePath);
                File.Move(filePath, csFilePath);
#pragma warning restore RS1035
            }
            catch (IOException ex)
            {
                // Add a diagnostic if file writing fails
                context.ReportDiagnostic(Diagnostic.Create("SG001", "FileEmit", $"Failed to write generated file: {ex.Message}", DiagnosticSeverity.Warning, DiagnosticSeverity.Warning, true, 1));
            }
        }

        context.AddSource($"{wrapperName}.g.cs", finalCode);
    }

    private string getMappedTypeName(ITypeSymbol typeSymbol, IReadOnlyDictionary<string, string> typeMap)
    {
        string fullName = typeSymbol.ToDisplayString();
        return typeMap.TryGetValue(fullName, out string wrapperName) ? wrapperName : fullName;
    }

    /// <summary>
    /// Convert Roslyn operator method names to their corresponding symbols.
    /// </summary>
    /// <param name="metadataName">Roslyn metadata name of the operator method.</param>
    /// <returns></returns>
    private string getOperatorSymbol(string metadataName)
    {
        switch (metadataName)
        {
            case "op_Addition": return "+";
            case "op_Subtraction": return "-";
            case "op_Multiply": return "*";
            case "op_Division": return "/";
            case "op_UnaryNegation": return "-";
            case "op_Equality": return "==";
            case "op_Inequality": return "!=";
            default: return null; // Unknown operator
        }
    }

    /// <summary>
    /// Get the parameter modifier (ref, out, in) for a given parameter symbol.
    /// </summary>
    /// <param name="parameter">The parameter symbol to check.</param>
    /// <returns>The parameter modifier as a string for use in method signatures.</returns>
    private string getParameterModifier(IParameterSymbol parameter)
    {
        return parameter.RefKind switch
        {
            RefKind.Out => "out ",
            RefKind.Ref => "ref ",
            RefKind.In => "in ",
            _ => ""
        };
    }

    /// <summary>
    /// Formats the raw documentation XML into lines prefixed with "/// ".
    /// </summary>
    private string formatDocumentation(string xml)
    {
        if (string.IsNullOrEmpty(xml)) return string.Empty;

        var doc = new XmlDocument();
        doc.LoadXml(xml);

        var builder = new StringBuilder();
        var childNodes = doc.DocumentElement?.ChildNodes;

        if (childNodes is null) return string.Empty;

        // Iterate through each node (<summary>, <param>, etc.) individually
        foreach (XmlNode node in childNodes)
        {
            // Get the complete tag as a string (e.g., "<summary>...</summary>")
            string nodeXml = node.OuterXml;
            if (string.IsNullOrWhiteSpace(nodeXml)) continue;

            // Split the tag's content by newlines, in case the original summary is multi-line
            string[] lines = nodeXml.Replace("\r\n", "\n").Split('\n');
            foreach (string line in lines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                // Add an extra space for better formatting in the final code
                builder.AppendLine($"    /// {line.Trim()}");
            }
        }
        return builder.ToString().TrimEnd();
    }

    private record StructInfo(string WrapperName, string NamespaceName, ITypeSymbol UnderlyingType)
    {
        public string UnderlyingTypeFullName => UnderlyingType.ToDisplayString();
        public string WrapperName { get; } = WrapperName;
        public string NamespaceName { get; } = NamespaceName;
        public ITypeSymbol UnderlyingType { get; } = UnderlyingType;
    }
}
